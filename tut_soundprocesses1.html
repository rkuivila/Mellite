<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>SP1 - Intro to SoundProcesses · Mellite</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='Mellite'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>

<!--
<link rel="shortcut icon" href="images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Mellite
</a>
<div class="version-number">
2.17.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="tutorials.html" class="page">Tutorials</a>
  <ul>
    <li><a href="tut_mellite_videos.html" class="page">Mellite Video Tutorials</a></li>
    <li><a href="tut_soundprocesses1.html" class="active page">SP1 - Intro to SoundProcesses</a></li>
    <li><a href="tut_soundprocesses2.html" class="page">SP2 - Understanding Objects</a></li>
    <li><a href="tut_soundprocesses3.html" class="page">SP3 - Linking and Interacting</a></li>
  </ul></li>
  <li><a href="links.html" class="page">Links</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="index.html">Mellite</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Mellite
</a>
<div class="version-number">
2.17.0
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="tutorials.html" class="page">Tutorials</a>
  <ul>
    <li><a href="tut_mellite_videos.html" class="page">Mellite Video Tutorials</a></li>
    <li><a href="tut_soundprocesses1.html" class="active page">SP1 - Intro to SoundProcesses</a></li>
    <li><a href="tut_soundprocesses2.html" class="page">SP2 - Understanding Objects</a></li>
    <li><a href="tut_soundprocesses3.html" class="page">SP3 - Linking and Interacting</a></li>
  </ul></li>
  <li><a href="links.html" class="page">Links</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="index.html">Mellite</a></li>
  <li><a href="tutorials.html">Tutorials</a></li>
  <li>SP1 - Intro to SoundProcesses</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#sp1-intro-to-soundprocesses" name="sp1-intro-to-soundprocesses" class="anchor"><span class="anchor-link"></span></a>SP1 - Intro to SoundProcesses</h1>
<p>If you have gone through the video tutorials of Mellite, you may wonder if there is more to it than the limited GUI interaction. In fact, Mellite is, properly speaking, only the graphical user interface layer on top of a system of computer music abstractions that is called <em>SoundProcesses</em>. When you create and manipulate objects in Mellite, you are actually creating and manipulating objects in SoundProcesses, through the GUI provided by Mellite. In order to make use of the power of the system, it is thus necessary to dive a bit deeper and learn about the application programming interface (API) provided by SoundProcesses. You may still access this API through Mellite, but you may also choose to write your sound programs directly in a general code editor or integrated development environment (IDE), such as IntelliJ IDEA.</p>
<p>The following figure illustrates the layers of the SoundProcesses and Mellite architecture:</p>
<img src="assets/images/tut_sp_architecture.png" alt="SoundProcesses Architecture" style="width:100%;max-width:520px;margin-bottom:1ex">
<p>In the following tutorial, we will write code as such an independent project, not making any references to Mellite. I will try to assume that you have not much experience with either Scala, ScalaCollider (the sound synthesis library used by SoundProcesses) or IntelliJ IDEA. However, I will also assume that you have some programming experience, perhaps in Java or SuperCollider, so that some concepts may be familiar, although you know them from a different language.</p>
<p>This tutorial will thus be a quite long trip, introducing you to all of these things step by step. Instead of giving a separate Scala tutorial (there are many resources <a href="http://scala-lang.org/documentation/learn.html">out on the Internet</a>), I will introduce Scala concepts as we encounter them.</p><div class="callout note "><div class="callout-title">Note</div>
<p>This tutorial is a living document. Please help improve it by reporting problems in understanding, errors, or by making suggestions on how to improve it. The best way is to pass by the <a href="https://gitter.im/Sciss/Mellite">Gitter chat room</a>, or if you can nail it down to a particular typo, problem or suggestion, by filing a ticket in the <a href="https://github.com/Sciss/Mellite/issues">issue tracker</a>.</p></div>
<h2><a href="#preparations" name="preparations" class="anchor"><span class="anchor-link"></span></a>Preparations</h2>
<p>I assume that you have <a href="http://supercollider.github.io/">SuperCollider</a>, <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java</a>, and <a href="https://git-scm.com/">git</a> already installed on your system, and proceed from there. You can either copy and paste the code snippets from this page, or clone the Mellite <a href="https://github.com/Sciss/Mellite/">website repository</a>. Let&rsquo;s do the latter. In the following, a dollar sign <code>$</code> indicates the terminal or shell prompt.</p>
<pre><code>$ cd ~/Documents  # or any place where you would like to download the repository to
$ git clone https://github.com/Sciss/Mellite-website.git
</code></pre>
<p>This will take a while, then you will find the snippets project in <code>Mellite-website/snippets</code>. You can see that directory <a href="https://github.com/Sciss/Mellite-website/tree/master/snippets">online</a>. This project uses <a href="http://www.scala-sbt.org/">sbt</a> as a build tool, however we&rsquo;ll just build and run from IntelliJ IDEA, so you don&rsquo;t actually have to install sbt at this point.</p>
<p>You can download IntelliJ IDEA <a href="https://www.jetbrains.com/idea/download/">here</a>. It is a development environment made by JetBrains, and it comes in two flavours&mdash;&lsquo;ultimate&rsquo; and &lsquo;community&rsquo;. The latter is free and open source, so we&rsquo;ll use that one. As of this writing, on Linux this will download <code>ideaIC-2017.2.2.tar.gz</code>. The archive can be unpacked anywhere, and the application can be launched with the shell script <code>bin/idea.sh</code>. If you have never run IntelliJ, it will ask you a few questions, among others it offers you to install some plugins. Make sure that you choose to install the &lsquo;Scala&rsquo; plugin. If you missed to do so, you can install plugins from within IntelliJ by going to Settings &gt; Plugins and looking for &lsquo;Scala&rsquo;.</p>
<p>Once IntelliJ has started, you should see its welcome screen:</p>
<p><img src="assets/images/tut_sp_idea_welcome.png" alt="IC Welcome" /></p>
<p>Choose &lsquo;open&rsquo; and navigate to the snippets directory inside the Mellite repository clone:</p>
<p><img src="assets/images/tut_sp_idea_open.png" alt="IC Open Project" /></p>
<p>Next, you will be asked how to import the project. IntelliJ will detect that sbt is used to build the project, so the defaults should be fine:</p>
<p><img src="assets/images/tut_sp_idea_import.png" alt="IC Import from SBT" /></p>
<p>If you have not set up a &lsquo;Project SDK&rsquo; yet, you&rsquo;ll first have to press &lsquo;New&hellip;&rsquo; &gt; JDK and locate your Java 8 installation (IntelliJ will probably guess it right).</p>
<p>Next, IntelliJ will build the project information, download all the necessary libraries for this project, and finally give you a project browser. If you don&rsquo;t see the browser, <kbd>Alt</kbd>-<kbd>1</kbd> will toggle it. Open the tree to <code>src</code> &gt; <code>main</code> &gt; <code>scala</code> &gt; <code>de.sciss.soundprocesses.tutorial</code>, and locate <code>Snippet1</code>, the source code of which you can open by double-clicking on it:</p>
<p><img src="assets/images/tut_sp_idea_project.png" alt="IC Project Browser" /></p>
<p>You can build (compile) the project by clicking the green downward arrow button in the top-right of the window or typing <kbd>Ctrl</kbd>-<kbd>F9</kbd> on the keyboard. If all goes fine, the status bar at the bottom should say something like</p>
<blockquote>
  <p>Compilation completed successfully in 5s 388ms (moments ago)</p>
</blockquote>
<p>If there was an error, a panel would pop up showing you the errors with links to the source code.</p>
<p>A few observations until here:</p>
<ul>
  <li>IntelliJ IDEA is an application that manages software projects, giving you a project browser with directories to the source code  of your project, a main editor window for creating and editing the source code, and actions to compile and run your code</li>
  <li>To edit Scala code, the Scala plugin for IntelliJ IDEA must be installed. It is capable of parsing build files for sbt, the  Scala Build Tool, probably the most widely used build system for Scala based projects. You can see how that build file looks  by double-clicking on <code>build.sbt</code>. At this moment, we take it for granted, but we&rsquo;ll see later what the essentials of these  build files are. Basically, they define which libraries and Scala version your project uses.</li>
  <li>By convention, source code in Scala projects resides in the directory <code>src/main/scala</code> (there could be other locations, for  example <code>src/test/scala</code> for unit test source code, or <code>src/main/java</code> if you mix with Java source code, etc.)</li>
  <li>By another convention, we use packages for code, which are nested namespaces. That avoids clashes when multiple projects  and libraries would otherwise use the same names for classes and objects. Following Java&rsquo;s tradition, packages are broken  up into &lsquo;reverse URL components&rsquo;, so for example all my projects begin with package <code>de.sciss</code>, typically followed by  further components clarifying the project, in this case <code>soundprocesses.tutorial</code>. You don&rsquo;t have to follow this pattern,  but it helps organise your code.</li>
</ul>
<p>IntelliJ IDEA can do a lot more things, like help you with versioning control (git), run a step debugger, and so forth. For now, we use it as a code editor, compiler and runner. The code editor is very powerful, giving you things such as auto-completion, offering intentions, easy navigation and look-up of methods and symbols you are using, showing you instantly errors and warnings, etc. If you&rsquo;ve worked with SuperCollider IDE, you&rsquo;ll notice that it is much more advanced; however, you will notice one big difference: IntelliJ doesn&rsquo;t directly give you an interpreter where you can live-code. There are possibilities so drop into an interpreter, but the focus is really to program a statically typed program. Mellite, in turn, has a much weaker IDE, but better access to a live-code interpreter.</p>
<p>Now let&rsquo;s run the first snippet. Select <code>Snippet1</code> in the project browser (tree view) and choose &lsquo;Run&rsquo; from the context menu or press <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>F10</kbd>:</p>
<p><img src="assets/images/tut_sp_idea_project.png" alt="IC Project Browser" /></p>
<p>There are (at least) three possible outcomes now. Either it works, and you hear the famous &lsquo;Analog Bubbles&rsquo; example sound of SuperCollider. In this case you have completed the preparations. Or, most likely on Linux, it seems to run without error but there is no sound&mdash;probably Jack is not well connected, we&rsquo;ll discuss that below. Or, most likely on macOS and Windows, you&rsquo;ll see a runtime exception, complaining that &lsquo;scsynth&rsquo; was not found, like this:</p>
<pre><code>Exception in thread &quot;Thread-2&quot; java.io.IOException: Cannot run program &quot;scsynth&quot;: error=2, No such file or directory
    at java.lang.ProcessBuilder.start(ProcessBuilder.java:1048)
    at de.sciss.synth.impl.Booting.p$lzycompute(Connection.scala:182)
</code></pre><div class="callout note "><div class="callout-title">Note</div>
<p>When you start a SuperCollider server from SoundProcesses, and you have not given any explicit information where SuperCollider is installed, it will look into the environment variable <code>SC_HOME</code> to find the directory of the server program <code>scsynth</code>. If that environment variable is absent, SoundProcesses will simply try to start <code>scsynth</code>, looking into the default locations for executables on your system. This is great on Linux, because here it will usually find <code>scsynth</code> automatically. But on macOS and Windows, you will have to either specify that environment variable, or provide an explicit path in your code.</p></div>
<p>The next subsection will address this problem.</p>
<h3><a href="#making-soundprocesses-find-supercollider" name="making-soundprocesses-find-supercollider" class="anchor"><span class="anchor-link"></span></a>Making SoundProcesses find SuperCollider</h3>
<p>There are different ways to set environment variables, including the possibility to set them globally on your system. The ScalaCollider read-me has a <a href="https://github.com/Sciss/ScalaCollider/blob/6c1758f480f3641b853de04d51d95a3da1c97f43/README.md#specifying-sc_home">section</a> showing how this worked on OS X 10.6, but I am not sure this information is still valid. What we&rsquo;ll do here, is simply tell IntelliJ to add such an environment variable.</p>
<p>You may have noticed that after running the snippet for the first time, its name appeared next to the green downward arrow in the top-right of the screen. Here you find the so-called &lsquo;run configurations&rsquo;, i.e. specifications which and how to run parts of your code. If you click on the name &lsquo;Snippet1&rsquo; here, a popup menu opens offering you to &lsquo;Edit Configurations&hellip;&rsquo;:</p>
<p><img src="assets/images/tut_sp_idea_edit_run_config.png" alt="IC Edit_Run_Config" /></p>
<p>Once you enter this dialogue, you&rsquo;ll see a dedicated section &lsquo;Environment variables&rsquo;. Clicking the &lsquo;&hellip;&rsquo; to its right opens a key-value editor for environment variables associated with that particular run configuration. Add a new entry here with name <code>SC_HOME</code> and the value being the full path of the directory where the SuperCollider server program <code>scsynth</code> (<code>scsynth.exe</code> on Windows) resides on your harddisk. On macOS, if you have a standard SuperCollider installation, the program is hidden inside the bundle of <code>SuperCollider.app</code>, so the path might be something like <code>/Applications/SuperCollider.app/Contents/Resources/</code>. Here I have entered to full path of my Linux installation:</p>
<p><img src="assets/images/tut_sp_idea_env_var.png" alt="IC Environment_Variables" /></p>
<p>After confirming all the dialogs, make sure you stop the hanging program with <kbd>Ctrl</kbd>-<kbd>F2</kbd> or by pressing the red stop button, and try to run it again using <kbd>Ctrl</kbd>-<kbd>F10</kbd> or the green play button. If you didn&rsquo;t make a typo, SuperCollider should boot now and play the familiar analog bubbles tune for about ten seconds before stopping automatically.</p>
<h3><a href="#fixing-jack-audio-routing" name="fixing-jack-audio-routing" class="anchor"><span class="anchor-link"></span></a>Fixing Jack Audio Routing</h3>
<p>On Linux, SuperCollider talks to your sound card through the <a href="http://www.jackaudio.org/">Jack Audio Connection Kit</a> (Jack). When you start the SuperCollider server and Jack doesn&rsquo;t run, SuperCollider will launch an instance itself. If this is the case you might see a message like this:</p>
<blockquote>
  <p>JACK server starting in realtime mode with priority 10<br> &hellip;<br> Acquire audio card Audio0<br> creating alsa driver &hellip; hw:0|hw:0|1024|2|48000|0|0|nomon|swmeter|-|32bit</p>
</blockquote>
<p>The problem with not hearing sound then is due to the fact, that you also to specify which output channels of SuperCollider should be wired to which channels of your sound card. There is one tinkering way to do that, and that is to set environment variables <code>SC_JACK_DEFAULT_INPUTS</code> and <code>SC_JACK_DEFAULT_OUTPUTS</code>. You can look at the previous subsection to learn how to add environment variables to a run configuration in IntelliJ. Here&rsquo;s an example value for <code>SC_JACK_DEFAULT_OUTPUTS</code> that would work in my case: <code>system:playback_1,system:playback_2</code>.</p>
<p>An, in my opinion, better approach however is to make use of a small tool that can manage all your jack connections through a patchbay. This tool is <a href="https://qjackctl.sourceforge.io/">QJackCtl</a>, and on Debian and Ubuntu the installation should be as simple as running <code>sudo apt install qjackctl</code>. You can create different presets for different sound cards in QJackCtl, patchbays that wire up clients such as SuperCollider with sound cards or other applications, and you start the Jack server from QJackCtl. When QJackCtl is running and you started Jack through it, as soon as SuperCollider boots, QJackCtl will notice it and make activate the appropriate patchbay wiring if you have defined one. Here is a screenshot of my default patchbay:</p>
<p><img src="assets/images/tut_sp_qjackctl_patchbay.png" alt="QJackCtl Patchbay" /></p>
<p>You can see that I populated it over time with many different clients. You can configure the client name of SoundProcesses, but by default it will be &lsquo;SuperCollider&rsquo;. From QJackCtl&rsquo;s main window, you can use the &lsquo;connect&rsquo; button to see which clients are currently running and how they are wired up. In this case, launching the example snippet, I have this situation:</p>
<p><img src="assets/images/tut_sp_qjackctl_connect.png" alt="QJackCtl Connections" /></p>
<p>Again by default, SuperCollider will boot with eight channels of in- and output. I have only wired the first two outputs to the stereo output of my internal sound card here. That&rsquo;s fine.</p>
<h2><a href="#hello-world" name="hello-world" class="anchor"><span class="anchor-link"></span></a>Hello World</h2>
<p>Before we go through the code of <code>Snippet1</code>, let us go one step back and see how the most basic Scala program can be created. The following snippet is from <code>HelloWorld.scala</code>:</p>
<pre class="prettyprint"><code class="language-scala">object HelloWorld extends App {
  println(&quot;Hello world!&quot;)
}</code></pre>
<p>This is more or less the shortest Scala program one can write. Let&rsquo;s take a moment to understand what happens here. Scala has two basic entities: <strong>values</strong> and <strong>types</strong>. A value can be a constant literal such as an integer number <code>123</code> or a double floating point number <code>1.234</code>, a boolean <code>true</code> or <code>false</code>, a string <code>&quot;Hello&quot;</code>, etc. Or a value can be a more complex <code>object</code>, i.e. something comprised of members (values, types, methods), possibly with some body of initialising statements. A type can be either some abstract type variable, or a specific class or trait. Classes and traits are very similar in Scala, the main difference being that classes can take constructor parameters, and a sub-class or object can only be derived from exactly one (super-)class, whereas they can be derived from multiple traits. We&rsquo;ll come to this later. What we see in the hello-world example is that one <code>object</code> is defined which is given the name <code>HelloWorld</code>, and the <code>extends App</code> clause means it derives from the trait <code>App</code> which is defined by the <a href="http://www.scala-lang.org/api/current/">standard Scala library</a> that is always available. The <code>App</code> trait is a shortcut for conveniently defining executable programs, so we thereby mark the object as a possible starting point for executing our program. When an <code>object</code> is evaluated, all the statements in its body, which is everything between the curly braces <code>{</code> and <code>}</code>, are executed sequentially. Here we have only a single statement, <code>println(&quot;Hello world&quot;)</code>.</p>
<p>When you right-click on <code>HelloWorld</code> in the project browser of IntelliJ and select &lsquo;run&rsquo;, IntelliJ will, like it did before with <code>Snippet1</code>, create a corresponding run configuration, if it doesn&rsquo;t exist yet, then launch that configuration. If we edit the configuration, we can see that <code>HelloWorld</code> is selected as the &lsquo;main class&rsquo;:</p>
<p><img src="assets/images/tut_sp_idea_hello_world_config.png" alt="IC Hello_World_Main" /></p>
<p>What you can see here also is that the fully qualified name is <code>de.sciss.soundprocesses.tutorial.HelloWorld</code>. This is because if you look into the file, we declared <code>package de.sciss.soundprocesses.tutorial</code> at the top of the file. As mentioned before, packages allow us to put symbols (such as the name <code>HelloWorld</code>) in places so we can later import them easily as we make use of them, and we avoid name clashes. Scala&rsquo;s packages are similar to Java&rsquo;s, but SuperCollider does not have any corresponding concept.</p>
<p>It may appear confusing that <code>HelloWorld</code> is the main <em>class</em>, because I just said there are values and objects on one side and types and classes on the other side. It so happens that an <code>object</code>, sometimes called <em>singleton</em> in Scala, also represents a class, however a very particular one, in that it cannot be explicitly instantiated, instead the object, once referred to, always represents the one singleton instance of its class.</p>
<p>The way we enter the main class is actually a pecularity of the Java Virtual Machine on which Scala runs. If we remove the <code>App</code> trait, we can be more explicit about this entry point:</p>
<pre class="prettyprint"><code class="language-scala">object HelloWorldExplicit {
  def main(args: Array[String]): Unit = {
    println(&quot;Hello world!&quot;)
  }
}</code></pre>
<p>What we have to do here explicitly for <code>HelloWorldExplicit</code> to work as an entry point to executing the program, is to define a method <code>main</code> as shown. Methods are defined with the <code>def</code> keyword, followed by the method&rsquo;s name, then optionally one or several groups of parentheses in which the method&rsquo;s arguments are specified. In Scala, values and arguments are specified as <code>name: Type</code>, contrary to some other languages such as Java, where the order is reversed as <code>Type name</code>. Once you get used to Scala&rsquo;s order, it actually makes a lot of sense, especially when considering that the <code>: Type</code> annotation can be left out for local values, where the compiler will then automatically infer the type. Of course, if you come from a dynamically typed language such as SuperCollider, this may all appear odd, as in those languages you typically do not state the (expected) type of arguments at all, but rely on the caller knowing what type to pass. Having to explicitly specify types may appear cumbersome in the beginning, but the huge advantage is that the compiler will check all invocations of your method at compile time and prevent calling a method with the wrong types of arguments before you even attempt to run the program.</p>
<p>If you are familiar with Java, here is the corresponding Java variant of <code>HelloWorldExplicit</code>:</p>
<pre class="prettyprint"><code class="language-java">public class HelloWorldJava {
    public static void main(String[] args) {
        System.out.println(&quot;Hello world!&quot;);
    }
}
</code></pre>
<p>In SuperCollider, there is no concept of a &lsquo;main class&rsquo;, so it doesn&rsquo;t really translate. But the code would be roughly as follows:</p>
<pre class="prettyprint"><code class="language-supercollider">HelloWorldSuperCollider {
    *main { |args|
      &quot;Hello world!&quot;.postln;
    }
}
</code></pre>
<p>In other words, methods in singleton objects in Scala can be compared with <code>static</code> methods in Java or <em>class methods</em> (with asterisk <code>*</code>) in SuperCollider. The argument passed to a main class in Scala is of type <code>Array[String]</code>. An array in Scala is very much like an array in SuperCollider, a mutable sequence of elements with constant access performance, with the distinctiveness that one has to specify the element type, so we cannot mix heterogenous elements within the same array, unless we give a very generic element type, e.g. <code>Array[Any]</code>, <code>Any</code> being the top type in Scala of which all other types are sub-types.</p>
<p>The <code>main</code> method is annotated with a <em>return type</em> <code>: Unit</code>, which roughly corresponds to <code>void</code> in Java. In SuperCollider, one would have <code>Nil</code> instead. The body of a method is written on the right-hand side of the equals symbol, so in general the shape of a method definition in Scala is</p>
<pre class="prettyprint"><code class="language-scala">def methodName(arg1: ArgType1, arg2: ArgType2, ...): ReturnType = Body`
</code></pre>
<p>By convention, method, argument and variable names begin with a lower case letter, and object names, types, class and trait names begin with an upper case letter, but there are circumstances when one would probably deviate from this convention. The body of a method can be written &ldquo;plain&rdquo; without extra ceremony, but if the body is formed of more than one statement, one has to group them together with curly braces <code>{</code>, <code>}</code>. It is never forbidden to place those braces even if they are not necessary. I have done that in the <code>main</code> method of <code>HelloWorldExplicit</code>. I could as well have written</p>
<pre class="prettyprint"><code class="language-scala">def main(args: Array[String]): Unit = println(&quot;Hello world!&quot;)
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-scala">def main(args: Array[String]): Unit = 
  println(&quot;Hello world!&quot;)
</code></pre>
<p>Here is a snippet where the braces are needed because we have multiple statements:</p>
<pre class="prettyprint"><code class="language-scala">object HelloWorldMultiple {
  def main(args: Array[String]): Unit = {
    val d = new java.util.Date
    println(&quot;Hello world! It is &quot; + d)
  }
}</code></pre>
<p>You may have noticed that we don&rsquo;t use semicolons between the statements. They are automatically inferred by Scala, and only rarely one needs to use semicolons (for example if one wants to place multiple statements on a single line). The last example also shows a <code>val</code> declaration. <code>val</code> stands for &lsquo;value&rsquo; and binds the right-hand side to a &ldquo;variable&rdquo; (symbol) on the left-hand side, although this &ldquo;variable&rdquo; is immutable, i.e. its value cannot be replaced. It&rsquo;s similar to a <code>let</code> statement in Lisp. Although Scala also has a <code>var</code> keyword for defining mutable variables, it is good practice to stick to <code>val</code>s whenever possible, as it greatly reduces the risk of cluttered code. Unlike SuperCollider where <code>var</code>s can only be defined at the very beginning of a method, in Scala we define the <code>val</code>s at the point where we actually assign their content. Like Java and SuperCollider, Scala has a <code>new</code> keyword to create an instance (value) of a class, in the previous example of the class <code>java.util.Date</code>. In SuperCollider, the <code>new</code> keyword is written as a class method, so it would be <code>Date.new</code>, and conveniently one can also drop the <code>.new</code> call and just write <code>Date()</code>. Scala has a similar feature called case-class, which we will learn about later, but in general, classes have be instantiated by writing <code>new ClassName</code>.</p>
<h2><a href="#playing-a-sound" name="playing-a-sound" class="anchor"><span class="anchor-link"></span></a>Playing a Sound</h2>
<p>After this dense prelude, let us look at the content of the first snippet that launches SuperCollider and plays a sound. Here is the full code:</p>
<pre class="prettyprint"><code class="language-scala">import de.sciss.lucre.synth.{InMemory, Server, Synth, Txn}
import de.sciss.synth.SynthGraph
import de.sciss.synth.proc.AuralSystem

object Snippet1 extends App {
  val cursor  = InMemory()
  val aural   = AuralSystem()

  val bubbles = SynthGraph {
    import de.sciss.synth._
    import ugen._
    val o = LFSaw.kr(Seq(8, 7.23)).madd(3, 80)
    val f = LFSaw.kr(0.4).madd(24, o)
    val s = SinOsc.ar(f.midicps) * 0.04
    val c = CombN.ar(s, 0.2, 0.2, 4)
    val l = Line.kr(1, 0, 10, doneAction = freeSelf)
    Out.ar(0, c * l)
  }

  cursor.step { implicit tx =&gt;
    aural.addClient(new AuralSystem.Client {
      def auralStarted(s: Server)(implicit tx: Txn): Unit = {
        val syn = Synth.play(bubbles)(s)
        syn.onEnd(sys.exit())
      }

      def auralStopped()(implicit tx: Txn): Unit = ()
    })

    aural.start()
  }
}</code></pre>
<p>The <code>object Snippet1 extends App</code> bit should be familiar now&mdash;it means we define an executable program in the body of this object. But almost everything else will be new, so let&rsquo;s go through it piece by piece:</p>
<h3><a href="#importing-symbols" name="importing-symbols" class="anchor"><span class="anchor-link"></span></a>Importing Symbols</h3>
<p>The first lines are comprised of <code>import</code> statements. Since values and types reside in packages, they are not automatically visible in a Scala program. There are a few exceptions such as everything that&rsquo;s in the <code>scala.</code> and <code>java.lang.</code> namespaces, for example we can write <code>String</code> although the fully qualified type is <code>java.lang.String</code>, and we can write <code>extends App</code> instead of <code>extends scala.App</code>. Typically, one imports the types one wishes to use at the top of a source code file, although it is not mandatory. At any point we can write the fully qualified name with the packages separated by dots, and there are even some conventions to do so in certain cases to make the intent more clear: For example Scala&rsquo;s standard library contains both immutable and mutable collections, so you could write <code>immutable.Set</code> and <code>mutable.Set</code> to visually distinguish them at the place where they are used without having to look up which one was imported. Since immutable is the recommended standard, it boils down to people using <code>Set</code> to indicate the immutable set, and <code>mutable.Set</code> to flag the use of the mutable variant. Actually, the fully qualified name is <code>scala.collection.mutable.Set</code>, so for this to work, one still needs an <code>import scala.collection.mutable</code>&mdash;that brings the package <code>mutable</code> into scope, just as you would bring a class into scope! This may be surprising, but you will see that Scala is designed around a principle of regularity, which means that it tries to apply the same principle to all things equally. A package is just a symbol as much as a class is a symbol, so if you can import a class, you should be able to import a package as well. In fact, you can also import values, e.g. <code>import math.Pi</code> to use the symbol <code>Pi</code>.</p>
<p>In the same spirit, Scala also tries to avoid arbitrary constraints for where you can write these things. Import statements can be written anywhere you like, at any nesting level. This is why I could write <code>import de.sciss.synth._</code> further down in the code, inside the <code>SynthGraph { ... }</code> block. It is intuitively clear that the imported symbols are now only visible within this particular block. Here the underscore <code>_</code> selects all symbols inside the package <code>synth</code>. This is a nice and short way of quickly getting hold of all the main types in <a href="sciss.github.io/ScalaCollider/">ScalaCollider</a>, the sound synthesis library used by SoundProcesses. Such &ldquo;wildcard import&rdquo; may have the disadvantage of bringing unwanted symbols into scope that could, for example, result in a name clash. That&rsquo;s the reason why I prefer here to place that import right where I will make use of it, but it would also have been possible to add it to the top of the file. Take a look at the next line, <code>import ugen._</code>. This could be called a recursive import, perhaps, because <code>ugen</code> is a sub-package inside <code>synth</code>, so I&rsquo;m abbreviating <code>import de.sciss.synth.ugen._</code> to <code>import ugen._</code> because it&rsquo;s less to type, and this is possible because the previous line imported everything that&rsquo;s inside <code>synth</code>, including the <code>ugen</code> sub-package.</p><div class="callout note "><div class="callout-title">Note</div>
<p>How would we possibly know which classes and types are hidden in which packages? There are two answers to this: First, make use of IntelliJ&rsquo;s auto-completion and import helper, and second, consult the API docs. The API docs for Scala&rsquo;s standard library are <a href="http://www.scala-lang.org/api/current/">here</a>, and those of Mellite and SoundProcesses are <a href="http://sciss.github.io/Mellite/latest/api/de/sciss/index.html">here</a>.</p></div>
<p>The API docs are the products of an automatic process called scala-doc, and these pages list the packages on the right-hand side, and at the top of the screen you have a search field. Say we want to know about <code>SynthGraph</code>, let&rsquo;s type that into the <a href="latest/api/de/sciss/index.html?search=SynthGraph">search box</a>:</p>
<p><img src="assets/images/tut_sp_api_docs_synthgraph.png" alt="API Search for SynthGraph" /></p>
<p>The left-hand side shows objects and types containing the search term, whereas the right-hand side tries to find methods and nested values and classes containing the search term. In &lsquo;entity results&rsquo;, we can spot the type <code>SynthGraph</code> as being part of package <code>de.sciss.synth</code> (this is the base package of ScalaCollider), there is another thing called <code>SynthGraphObj</code> in package <code>de.sciss.synth.proc</code>&mdash;that&rsquo;s the base package of SoundProcesses. We were looking for the former. You can see two small icons to the left of the name, a dark blue &lsquo;O&rsquo; and a green &lsquo;C&rsquo;. The &lsquo;O&rsquo; stands for singleton object, the &lsquo;C&rsquo; stands for class. A light blue &lsquo;T&rsquo; stands for trait, remember that traits are like classes but without constructor arguments. Often in Scala, a class or trait has a corresponding object of the same name, that is called the <em>companion object</em>. Often static members and constructor methods of a class or trait are found on the companion object, that&rsquo;s why they are grouped together in the API docs.</p>
<p>In IntelliJ, if a symbol is not in scope, for example if we removed the import statements from the snippet source, the editor renders them in red, with a tool-tip indicating that <kbd>Alt</kbd>-<kbd>Enter</kbd> would bring up an import helper dialog:</p>
<p><img src="assets/images/tut_sp_idea_import_helper.png" alt="IntelliJ Import Helper" /></p>
<p>The import helper will show you all classes matching the name within all libraries of your project, highlighting the most likely candidate (<code>de.sciss.synth.SynthGraph</code> here). When you confirm this dialog, IntelliJ will add the import to the top portion of your source code. Auto-completion works while you type. For example, imagine that <code>SynthGraph</code> wasn&rsquo;t imported yet, and you begin typing <code>val bubbles = SynthG</code>…, then you&rsquo;ll notice that below your cursor IntelliJ lists the possible candidates to complete the name you are writing:</p>
<p><img src="assets/images/tut_sp_idea_import_completer.png" alt="IntelliJ Import Completer" /></p>
<p>Here, for some reason, the symbol we want is the second row; we can use the cursor keys and then press <kbd>Enter</kbd> to select and import it. IntelliJ is very smart with the auto-completion, it suffices to give some hints in the <a href="https://en.wikipedia.org/wiki/Camel_case#Programming_and_coding">&ldquo;camel-case&rdquo;</a> way, for example writing <code>val bubbles = SG</code>… will also find the <code>SynthGraph</code> symbol we are looking for.</p>
<h3><a href="#defining-a-synthgraph" name="defining-a-synthgraph" class="anchor"><span class="anchor-link"></span></a>Defining a SynthGraph</h3>
<p>The sound we are hearing is mainly defined by the <code>SynthGraph { ... }</code> block, so let&rsquo;s dive into that. I&rsquo;m reproducing it here again:</p>
<pre class="prettyprint"><code class="language-scala">val bubbles = SynthGraph {
  import de.sciss.synth._
  import ugen._
  val o = LFSaw.kr(Seq(8, 7.23)).madd(3, 80)
  val f = LFSaw.kr(0.4).madd(24, o)
  val s = SinOsc.ar(f.midicps) * 0.04
  val c = CombN.ar(s, 0.2, 0.2, 4)
  val l = Line.kr(1, 0, 10, doneAction = freeSelf)
  Out.ar(0, c * l)
}</code></pre>
<p>You may know that in SuperCollider, sound synthesis functions are defined within a <code>SynthDef</code>. This type also exists in ScalaCollider, but you will rarely deal with it directly. Instead, the <code>SynthGraph</code> is a slightly higher level abstraction that will be eventually translated into a <code>SynthDef</code> by the system. The main two differences are:</p>
<ul>
  <li>a <code>SynthGraph</code> does not have a name. Names are assigned automatically by the system, although you can give a name-hint when creating a synth, which might be helpful for  debugging purposes</li>
  <li>a <code>SynthGraph</code> preserves the graph elements in their &ldquo;unexpanded&rdquo; way. When the system translates the <code>SynthGraph</code> into a <code>SynthDef</code>, it enforces things like multi-channel-expansion  and thereby translates each graph element in one or several UGens or constants, optimises away dead branches, etc. To give an example, there are graph elements which expand to other  graph elements and do not have a direct correspondance with one UGen. In SuperCollider, these are sometimes called pseudo-UGens. A typical pseudo-UGen is <code>Mix</code>. In SuperCollider, when  you write <code>Mix([ PinkNoise.ar(0.1), FSinOsc.ar(801, 0.1), LFSaw.ar(40, 0.1)])]</code>, you immediately get the expanded <code>Sum3</code> UGen, whereas in ScalaCollider, an instance of the <code>Mix</code> class  will actually be stored in the <code>SynthGraph</code>. Or if you write <code>SinOsc.ar([400, 600])</code> in SuperCollider, you immediately get an array of two <code>SinOsc</code> UGens, whereas in ScalaCollider the  graph element <code>SinOsc</code> is one object with the multi-channel input. This behaviour enables a number of interesting ways in which synth graphs can be manipulated and extended.  For SoundProcesses, it means you will have a great number of graph elements which bridge the <code>Synth</code> to its environment such as control inputs, even if those inputs are not yet  defined or determined at the moment the graph function is written. This makes the <code>SynthGraph</code> in SoundProcesses more akin to the functions in SuperCollider&rsquo;s JITLib.</li>
</ul>
<p>Other than that, creating a <code>SynthGraph</code> looks exactly like creating a <code>SynthDef</code> (minus the naming). The graph elements corresponding with UGens are written almost identical to their SuperCollider counterparts. The analog bubbles graph in SuperCollider would be written like this:</p>
<pre class="prettyprint"><code class="language-supercollider">b = SynthDef(\bubbles, {
  var o = LFSaw.kr([8, 7.23]).madd(3, 80);
  var f = LFSaw.kr(0.4).madd(24, o);
  var s = SinOsc.ar(f.midicps) * 0.04;
  var c = CombN.ar(s, 0.2, 0.2, 4);
  var l = Line.kr(1, 0, 10, doneAction: 2);
  Out.ar(0, c * l)
});
</code></pre><div class="callout note "><div class="callout-title">Note</div>
<p>Using <code>.madd</code> calls in SuperCollider is not very common. Most UGens do have artificial trailing inputs for multiplication and addition, which are then rewritten as <code>.madd</code> calls that produce the according binary-op or <code>MulAdd</code> UGen. I didn&rsquo;t adopt this approach in ScalaCollider, so here you have to explicitly use <code>.madd</code> to scale the output of UGens.</p></div>
<p>The syntactic differences are minimal&mdash;you would prefer <code>val</code> over <code>var</code>, dispense with the semicolons, and named arguments are filled with an equals character instead of a period, so it&rsquo;s <code>doneAction = freeSelf</code> instead of <code>doneAction: freeSelf</code> (in newest SuperCollider, you can write <code>doneAction: \freeSelf</code>, whereas in older versions you have to use the integer code <code>doneAction: 2</code>). Perhaps the greatest difference here is how multi-channel-expansion arguments are written. In SuperCollider, array literals are written using brackets <code>[</code>, <code>]</code>. In Scala, the brackets are reserved for type parameters, so there is no direct way of writing an array literal. One could write <code>Array(8, 7.23)</code> to create an array, but ScalaCollider requires that you use one of Scala&rsquo;s standard sequential collection types instead. <a href="http://docs.scala-lang.org/overviews/collections/overview.html">Here</a> is an overview of Scala&rsquo;s collections types. We will mostly write <code>Seq(...)</code> or <code>List(...)</code> to create multi-element arguments for UGens to produce multi-channel-expansion. <code>Seq</code> is the shortest, and an abstract trait, whereas <code>List</code> is a concrete implementation, an immutable singly-linked-list similar to a <a href="https://en.wikipedia.org/wiki/Cons#Lists">cons-list</a> in Lisp languages.</p>
<p>If you are completely unfamiliar with SuperCollider, here are the core concepts of UGen graphs:</p>
<ul>
  <li>a sound signal processing graph is created by &ldquo;plugging&rdquo; a number of so-called Unit Generators (UGens) into one another. A UGen is a building block of a DSP function that takes a number  of inputs (or zero, if it is a pure generator) and produces a number of outputs (or zero, if it is a pure sink with side effects, e.g. sending a signal to the sound hardware).</li>
  <li>the UGens are implemented as classes with constructor methods on their companion objects that are usually called <code>.ar</code>, <code>.kr</code> and <code>.ir</code>. These indicate the calculation rate of the UGen.  In the SuperCollider server, UGens can either run at full audio rate (<code>ar</code>) or at a reduced control rate (<code>kr</code>). <code>ir</code> is a special case of control rate, called scalar or init rate,  where the UGen&rsquo;s value is calculated only once when the synthesis process is started.</li>
  <li>so we can read the function from top to bottom: <code>LFSaw.kr</code> creates a low-frequency (LF) sawtooth oscillator with a frequency in Hertz given by its argument. Like many oscillators, the output of  this sawtooth runs between -1 to +1, so the subsequent <code>.madd</code> wraps this UGen in a second UGen that scales this value range to the range (-1 * 3 + 80 = 77) to (+1 * 3 + 80 = 83).</li>
  <li>the next line produces another sawtooth oscillator at 0.4 cycles per second, mixing its output with the previous sawtooth oscillator,  producing the nominal range (-1 * 24 + 77 = 53) to (+1 * 24 + 83 = 107).</li>
  <li>the next line creates a sine oscillator at audio rate, the frequency between the summed sawtooth oscillators fed through the <code>.midicps</code> unary operator function, translating from  <a href="https://en.wikipedia.org/wiki/MIDI_tuning_standard#Frequency_values">midi pitch</a> values to Hertz. The sine oscillator frequency thus moves in the range (53.midicps = 174.6) to (107.midicps = 3951.1). The amplitude of the sine&rsquo;s nominal -1 to +1 is scaled by  the factor 0.04 or -28 dB.</li>
  <li>the <code>CombN</code> UGen is a non-interpolating comb filter, the input here being the sine oscillator, using a fixed delay time of 0.2 seconds and a 60 dB decay time of 4 seconds. It reverberates  the sine oscillator.</li>
  <li>the <code>Line</code> UGen defines a ramp going down from 1 to 0 in 10 seconds, with the <code>doneAction</code> argument specifying that the entire synthesis graph should be stopped once the target value has  been reached. We multiply the comb filter with this ramp, thereby slowly fading the sound out.</li>
  <li>the <code>Out</code> UGen sends the faded comb to the audio interface&rsquo;s first channel (bus index 0 corresponds with the first output channel).</li>
</ul>
<p>Since the first sawtooth oscillator takes a sequence of two values, <code>Seq(8, 7.23)</code>, as its frequency argument, this essentially creates a two-channel signal here in the graph, which will automatically propagate through the entire graph, as this oscillator becomes the argument of other oscillators. The <code>Out</code> UGen then correctly &ldquo;consumes&rdquo; the two-channel signal, meaning that it writes the first channel to bus index 0, and the second channel to the adjacent bus index 1, sending thus a stereo signal to the sound card. If we looked at the expanded UGen graph, it would look like this:</p>
<img src="assets/images/tut_sp_bubbles-graph.svg" alt="Bubbles UGen Graph" style="width:100%;max-width:760px;margin-bottom:1ex">
<h3><a href="#transactional-and-aural-system" name="transactional-and-aural-system" class="anchor"><span class="anchor-link"></span></a>Transactional and Aural System</h3>
<p>We now return to the beginning of the snippet, with the following two lines:</p>
<pre class="prettyprint"><code class="language-scala">val cursor  = InMemory()
val aural   = AuralSystem()</code></pre>
<p>Here is where SoundProcesses for the first time diverges from &ldquo;plain&rdquo; ScalaCollider. ScalaCollider is written with a simple mutable and imperative model in mind. For example, when you write <code>Synth.play</code> in ScalaCollider, that action directly sends out OSC messages to the sound synthesis server. When a buffer information is updated, it mutates information fields in the client side <code>Buffer</code> representation. In contrast, SoundProcesses is designed on top of a <a href="https://en.wikipedia.org/wiki/Software_transactional_memory">software transactional memory</a> (STM). This is a kind of compromise between the imperative model and the purely functional model, where model updates would never be destructive but create new trees that replace the old trees. STM gives us good things from both imperative and functional models: We can still run commands as if they were imperative, and we don&rsquo;t need to &ldquo;thread state&rdquo; throughout our program, something that works for small scale applications, but becomes very difficult in larger and interactive scenarios. On the other hand, destructive changes are deferred to the moment, where a so-called transaction is successfully completed (committed). If at any point &ldquo;inside&rdquo; the transaction a problem occurs, all pending changes to the system are rolled back, and no destructive actions, such as sending OSC messages, are performed. Theoretically, this also allows the program to run fully concurrently (remember that SuperCollider uses cooperative multi-tasking and is essentially single-threaded, thereby avoiding the problem of concurrent mutable state, while introducing the problem of not being able to run processes in parallel). In practice, transactions can become quite big and thus chances are high that concurrent transactions collide and will be rolled back and retried at the cost of additional running time. Most of the time, this is not an issue, however, as most programs can indeed be dispatched on a single thread and no concurrent transactions.</p>
<p>When I said that SoundProcesses is based on STM, this is only half of the truth. In fact, we use an abstraction from STM that allows us at the same time to move objects from memory to the harddisk. If you have worked with Mellite, you&rsquo;ll know that editing things in the workspace are automatically persisted in the workspace database on disk. This happens automatically, because when a &ldquo;durable&rdquo; workspace is used, instead of just an in-memory STM, the transactions of the STM are coupled to <a href="https://en.wikipedia.org/wiki/ACID">ACID</a> database transactions. In SoundProcesses speak, the memory model used is a &ldquo;system&rdquo;. The system, embodied by trait <code>de.sciss.lucre.Sys</code> and the extension <code>de.sciss.lucre.synth.Sys</code> that adds sound synthesis abstractions, can be one of <code>InMemory</code>, <code>Durable</code> and <code>Confluent</code>. The first is essentially a plain STM with no storage on a secondary memory. This is the system we use in our example snippet. The call <code>InMemory()</code> creates such a system. <code>Durable</code> would be the variant that stores all objects on the disk, and <code>Confluent</code> would extend the durable case by adding confluent persistence, which means the history of the changes to objects is preserved as well. In the example snippet, there aren&rsquo;t actually any objects that could be persisted, so changing to <code>Durable</code> wouldn&rsquo;t make any difference. We will see in later tutorials how specific objects are created in SoundProcesses. Here, we simply provide a system that is necessary to interoperate with the sound synthesis related types such as <code>AuralSystem</code> and <code>Synth</code>. These only use the STM part of the system, so they wouldn&rsquo;t interact with the persistence layer.</p>
<p><code>AuralSystem</code> in SoundProcesses embodies the object that can boot a SuperCollider server. It&rsquo;s methods are transactional, and that&rsquo;s why we have to create a system such as <code>InMemory</code> first. Let&rsquo;s look at the code that uses the aural system:</p>
<pre class="prettyprint"><code class="language-scala">cursor.step { implicit tx =&gt;
  aural.addClient(new AuralSystem.Client {
    def auralStarted(s: Server)(implicit tx: Txn): Unit = {
      val syn = Synth.play(bubbles)(s)
      syn.onEnd(sys.exit())
    }

    def auralStopped()(implicit tx: Txn): Unit = ()
  })

  aural.start()
}</code></pre>
<p>The value <code>cursor</code> holds our instance of <code>InMemory</code>. Most systems are at the same time &ldquo;cursors&rdquo; which means they provide a means to issue a transaction through the <code>step</code> method. When we write <code>cursor.step { implicit tx =&gt; ... }</code> we encapsulate everything that is inside the curly braces in a transaction. When that method returns, the transaction has been closed and committed. The basic definition of <a href="latest/api/de/sciss/lucre/stm/Cursor.html">Cursor</a> is</p>
<pre class="prettyprint"><code class="language-scala">trait Cursor[S &lt;: Sys[S]] {
  def step[A](fun: S#Tx =&gt; A): A
}
</code></pre>
<p>For somebody familiar with Scala, this is straight forward, and in this case you can skip the next paragraphs; but otherwise this needs extensive explanation. The <code>Cursor</code> trait has a type constructor argument <code>S</code> which is constrained by the recursive formulation <code>&lt;: Sys[S]</code>. Technically, this means the type <code>S</code> is F-bounded. Practically, it means that <code>S</code> must be a sub-type of <code>Sys</code>. In our example, <code>S</code> would be equal to <code>InMemory</code>. Almost all abstractions in SoundProcesses exhibit this <code>S &lt;: Sys[S]</code> type parameter. It means that an object is always configured with a particular type of transactional system&mdash;in-memory, durable, etc.&mdash;and that in order to use it you must provide a matching transaction. This prevents for example that a durable object could be manipulated with an in-memory transaction for which no database handle exists. If we replace <code>S</code> by <code>InMemory</code>, the <code>step</code> method becomes</p>
<pre class="prettyprint"><code class="language-scala">def step[A](fun: InMemory#Tx =&gt; A): A
</code></pre>
<p>The strange looking type <code>InMemory#Tx</code> is called a type-projection in Scala, and you can simply think of it here as a type member provided by <code>InMemory</code>. All transactions share a common interface <a href="latest/api/de/sciss/lucre/stm/Txn.html">Txn</a> which is capable, among other things, of creating primitive transactional variables. The argument to <code>step</code> is a <em>function</em> of arity 1, that is a function that takes a single argument of type <code>InMemory#Tx</code> and returns a value of type <code>A</code>. In Scala, <code>A =&gt; B</code> is shorthand for <code>Function1[A, B]</code>. Often we provide functions as <a href="https://en.wikipedia.org/wiki/Anonymous_function">lambdas</a>, also called anonymous functions or function literals. Let&rsquo;s take a simpler example, using a collection, say <code>List(1, 2, 3, 4)</code>. A list, formally <code>List[A]</code> where <code>A</code> is the type of the elements in the list, has a method <code>filter</code> defined as follows:</p>
<pre class="prettyprint"><code class="language-scala">def filter(pred: A =&gt; Boolean): List[A]
</code></pre>
<p>In other words, <code>filter</code> takes a predicate, a function returning a boolean, and applies it to all of its elements, collecting in a resulting new list of the same element type only those elements for which the predicate holds (yields <code>true</code>).</p>
<pre class="prettyprint"><code class="language-scala">List(1, 2, 3, 4).filter({ x =&gt; x &gt; 2 })
</code></pre>
<p>The result will be <code>List(3, 4)</code>. The filter function in SuperCollider&rsquo;s collections is called <code>select</code> and acts very similarly:</p>
<pre class="prettyprint"><code class="language-supercollider">List[1, 2, 3, 4].select({ |x| x &gt; 2 })
</code></pre>
<p>Very similar to SuperCollider, when the sole argument of a method is a function, we can drop the parentheses and just use the curly braces:</p>
<pre class="prettyprint"><code class="language-scala">List(1, 2, 3, 4).filter { x =&gt; x &gt; 2 }
</code></pre>
<p>On the other hand, if the lambda only occupies a single line, we can also do the opposite&mdash;keep the method invocation parentheses and drop the curly braces:</p>
<pre class="prettyprint"><code class="language-scala">List(1, 2, 3, 4).filter(x =&gt; x &gt; 2)
</code></pre>
<p>Sometimes you&rsquo;ll also see this shortcut (again, something similar exists in SuperCollider):</p>
<pre class="prettyprint"><code class="language-scala">List(1, 2, 3, 4).filter(_ &gt; 2)
</code></pre>
<p>So back to the <code>step</code> method. When invoked, it calls the function argument, passing it a fresh transaction, then returns the function&rsquo;s result to the caller. A distinctive feature of Scala is that both an argument list of a method definition and the argument list of a function literal can be qualified with the modifier <code>implicit</code>. To understand this, let&rsquo;s look at the <code>start</code> method of <code>aural</code> that is invoked at the end of the cursor-step block. Its definition is:</p>
<pre><code>trait AuralSystem {
  def start(config: Config = Server.Config(), connect: Boolean = false)(implicit tx: Txn): Unit
}
</code></pre>
<p>First of all, we can see <em>default arguments</em> provided for <code>config</code> and <code>connect</code>. These are used when no arguments are specified in the invocation. Since we call <code>aural.start()</code> the default arguments for <code>config</code> and <code>connect</code> are both filled in automatically. If we wanted to customise the SuperCollider server, we would provide a <code>config</code> argument, like so:</p>
<pre class="prettyprint"><code class="language-scala">val config = Server.Config()
config.outputBusChannels = 4
aural.start(config)</code></pre>
<p>More importantly, <code>start</code> has a <em>second</em> argument list given as <code>(implicit tx: Txn)</code>, but in our call <code>aural.start()</code> there is no sign of this argument list. This is exactly because it is marked as <code>implicit</code>. We can call methods without providing arguments for an implicit argument list in Scala, and in that case the compiler will look for us in the current scope for implicit values matching the expected argument type(s). Because the lambda <code>implicit tx =&gt; ...</code> has indeed marked the transaction argument as <code>implicit</code>, it will now be automatically passed into the second, implicit argument list of <code>start</code>. Scala also allows us to specify this argument explicitly, so we could also have written:</p>
<pre class="prettyprint"><code class="language-scala">cursor.step { tx =&gt;
  aural.start()(tx)
}</code></pre>
<p>Since the entire interface of SoundProcesses uses transactions, it would be extremely annoying and impeding for the eye if we had to pass the <code>tx</code> transaction values everywhere. Thanks to implicits in Scala, the compiler can do this job for us. Implicits are a great way to pass contexts along in an API. There are other ways in which implicits are used, for example in ScalaCollider, when you use a constant number as a UGen input, say <code>SinOsc.ar(440)</code>, this number <code>440</code> of type <code>Int</code> is implicitly lifted to another type <code>Constant(440)</code> which is part of the graph element API of ScalaCollider. This is called <em>implicit conversion</em> and is a bit more complex than just <em>implicit arguments</em> and <em>implicit values</em>. And there are more cases. For now, it suffices to understand that the transactional interface in SoundProcesses always uses an implicit argument of type <code>Txn</code> or <code>S#Tx</code>. The former is a &ldquo;generic&rdquo; transaction that only gives STM information, and it is used by the sound synthesis level that has no business with persisting objects. The latter, <code>S#Tx</code>, is the particular transaction type of a system <code>S</code> (such as <code>InMemory#Tx</code> or <code>Durable#Tx</code>), and it is used wherever an object may participate in the storage of a workspace.</p>
<p>Before we start the aural system&mdash;which means that the SuperCollider server will be booted when the transaction is committed&mdash;we register a callback of type <code>AuralSystem.Client</code> which will be invoked when the server has completed booting or was quit. Using <code>new Type { ...definitions }</code> is an ad-hoc way to implement a trait such as <code>AuralSystem.Client</code>. That trait says there are two abstract methods <code>auralStarted</code> and <code>auralStopped</code> which must be implemented by us. We don&rsquo;t care about the server quitting, so we simply say <code>def auralStopped()(implicit tx: Txn): Unit = ()</code> where <code>()</code> is an empty value meaning &ldquo;do nothing&rdquo;. We <em>do</em> want to react to the server having booted, though, so we define the behaviour of <code>auralStarted</code>:</p>
<pre class="prettyprint"><code class="language-scala">def auralStarted(s: Server)(implicit tx: Txn): Unit = {
  val syn = Synth.play(bubbles)(s)
  syn.onEnd(sys.exit())
}</code></pre>
<p>The method is invoked with the <code>Server</code> as first argument, and again there is a second implicit argument list that gives us a transaction. That transaction is necessary to be able to use <code>Synth.play</code>, as this call requires an implicit transaction. You may be tempted to think that <code>Server</code> is ScalaCollider&rsquo;s <code>de.sciss.synth.Server</code> and that <code>Synth</code> is <code>de.sciss.synth.Synth</code>, but if you look at the imports, they are actually in a different package: <a href="latest/api/de/sciss/lucre/synth/Server.html"><code>de.sciss.lucre.synth.Server</code></a> and <a href="latest/api/de/sciss/lucre/synth/Synth.html"><code>de.sciss.lucre.synth.Synth</code></a>. There are, in other words, classes mirroring the familiar ScalaCollider classes, but now, inside SoundProcesses, they are changed to transactional semantics. If we call <code>Synth.play</code>, that <code>/s_new</code> OSC message is not fired straight away, but only after the transaction is successfully completed will such a message be sent to the server. Moreover, the methods are enhanced, because SoundProcesses does a lot more work to manage synthesis instances, including the automatic registration of a synth-def, preparing buffers, and so on. SoundProcesses takes care to correctly package the OSC bundles when there are asynchronous preparations, such as allocating and filling a buffer. Here is the definition of the <code>Synth.play</code> method:</p>
<pre class="prettyprint"><code class="language-scala">object Synth {
  def play(graph: SynthGraph, nameHint: Option[String] = None)
          (target: Node, args: ISeq[ControlSet] = Nil, addAction: AddAction = addToHead, dependencies: List[Resource] = Nil)
          (implicit tx: Txn): Synth = ...
}
</code></pre>
<p>So it is quite different from ScalaCollider:</p>
<ul>
  <li>instead of the name of a <code>SynthDef</code> that we had to take care to have sent to the server, here we directly give a <code>SynthGraph</code> along with  an optional name-hint.</li>
  <li>there is a new argument <code>dependencies</code> that is used when the system must ensure that those dependencies are met before the synth can be  actually started. The most common <code>Resource</code> type is <a href="latest/api/de/sciss/lucre/synth/Buffer.html"><code>Buffer</code></a>.</li>
  <li>again an implicit transaction <code>Txn</code> is needed</li>
</ul>
<p>Similar to ScalaCollider, we can pass the server <code>s</code> for the <code>target</code> argument, because it will be implicitly converted to <code>s.defaultGroup</code> to provide the required <code>Node</code> type. Here, the system will automatically cache synth-defs, so if we start multiple synths with the same synth-graph, only in the first iteration will a synth-def be created and sent to the server.</p>
<p>It remains to look at the second statement: <code>syn.onEnd(sys.exit())</code>. This registers a non-transactional callback invoked when the synth has been removed from the server. There is also a variant <code>onEndTxn</code> that can be used when we need a transactional context. Here we simply exit the virtual machine and thus quit the program execution.</p>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/Sciss/Mellite-website/tree/master/src/paradox/tut_soundprocesses1.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="tut_soundprocesses2.html">SP2 - Understanding Objects</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="tut_soundprocesses1.html#sp1-intro-to-soundprocesses" class="header">SP1 - Intro to SoundProcesses</a>
  <ul>
    <li><a href="tut_soundprocesses1.html#preparations" class="header">Preparations</a></li>
    <li><a href="tut_soundprocesses1.html#hello-world" class="header">Hello World</a></li>
    <li><a href="tut_soundprocesses1.html#playing-a-sound" class="header">Playing a Sound</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2017</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

</html>
